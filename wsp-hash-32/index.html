<!DOCTYPE html><html lang="en"><head><title>WSP-Hash-32: The Fastest Portable 32-Bit Hashing Algorithm</title><link href="https://williamstaffordparsons.github.io/wsp-hash-32/" rel="canonical"><link href="/favicon.ico" rel="icon" type="image/x-icon"><meta content="initial-scale=1,width=device-width" name="viewport"><meta charset="utf-8"><style type="text/css">a{color:#000;font-weight:bold;letter-spacing:-0.2px;text-decoration:none;}body,html{background:#fff;color:#000;font-family:sans-serif;font-size:14px;font-weight:normal;line-height:25px;margin:0;overflow-x:hidden;width:100%;}code{background:#eee;border-radius:4px;box-sizing:border-box;color:#111;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;height:auto;letter-spacing:-0.2px;line-height:19px;margin:8px 0 17px;overflow-x:scroll;padding:28px 31px 25px;white-space:pre;width:100%}footer{display:inline-block;margin:100px 0;width:100%;}footer ul{display:inline-block;}footer ul{margin:55px 0 0;padding:0;width:100%;}footer ul li{display:inline-block;float:left;line-height:18px;margin:0 15px 5px 0;}footer ul li a{font-size:12px;float:left;}footer .social-media a{display:block;float:left;}footer .social-media a img{height:16px;}h1,h2,h3{display:inline-block;font-weight:normal;text-transform:uppercase;width:100%;}h1{font-size:23px;letter-spacing:-0.9px;line-height:32px;margin:-6px 0 34px;word-spacing:1.4px;}h2{font-size:19px;letter-spacing:-0.6px;line-height:42px;margin:0 0 24px;padding-top:18px;}h3{font-size:14px;letter-spacing:-0.3px;margin:10px 0 20px;}p{box-sizing:border-box;color:#555;display:inline-block;margin:0 0 17px;width:100%;}p .code{background:#eee;border-radius:4px;color:#111;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;letter-spacing:-0.2px;line-height:17px;margin:2px 1px;padding:4px 6px 0;}.game{background:#000;border-radius:4px;box-sizing:border-box;margin:0 0 30px;padding:21px 32px;position:relative;}.game.no-margin-top{margin-top:5px !important;}.game a{height:100%;left:0;position:absolute;text-indent:-9999px;top:0;width:100%;}.game h3{color:#fff;font-weight:bold;line-height:30px;margin:3px 0 0;}.game img{display:block;height:32px;margin-top:12px;width:32px;}.game p{color:#999;margin-bottom:5px;}.icon{float:left;line-height:32px;}.icon img{float:left;height:32px;margin-right:15px;}.no-margin-bottom{margin-bottom:0 !important;}.no-margin-left{margin-left:0 !important;}.no-margin-top{margin-top:0 !important;}.section{margin-bottom:40px;position:relative;}</style></head><body><div style="box-sizing:border-box;margin:0 auto;max-width:720px;padding:0 25px;width:100%;"><header style="display:inline-block;padding:105px 0 70px;width:100%;"><a class="icon" href="/"><img src="/icon.jpg">William Stafford Parsons</a></header><main style="min-height:280px;width:100%;"><h1>WSP-Hash-32: The Fastest Portable 32-Bit Hashing Algorithm With Aligned Multi-Byte Memory Reading and Good Quality</h1><div class="section"><p><a href="https://github.com/williamstaffordparsons/wsp-hash-32">WSP-Hash-32</a> is a 32-bit hashing algorithm as a substantial improvement to CityHash32 v1.1, Lookup3, 32-bit MurmurHash3 and XXHash32.</p</div><div class="section"><h2>Library</h2><h3 class="no-margin-top">Source</h3><p><a href="https://raw.githubusercontent.com/williamstaffordparsons/wsp-hash-32/refs/heads/master/wsp_hash_32.c">wsp_hash_32.c</a><br><a href="https://raw.githubusercontent.com/williamstaffordparsons/wsp-hash-32/refs/heads/master/wsp_hash_32.h">wsp_hash_32.h</a></p><h3>Reference</h3><p><span class="code">wsp_hash_32()</span> is the all-at-once hashing function that accepts the 2 following arguments in left-to-right order.</p><p>1: <span class="code">input_count</span> is the <span class="code">unsigned long</span> count of elements in the <span class="code">input</span> array.</p><p>2: <span class="code">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p>The return value data type is <span class="code">uint32_t</span>.</p><p>It returns the 32-bit unsigned integer hash digest result.</p><p><span class="code no-margin-left">wsp_hash_32_initialize()</span> is the initialization function that accepts the following argument.</p><p>1: <span class="code">s</span> is the <span class="code">struct wsp_hash_32_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_32_transform()</span> is the core hashing loop function that accepts the 4 following arguments in left-to-right order.</p><p>1: <span class="code">i</span> is the <span class="code">unsigned long</span> starting index position of elements in the <span class="code">input</span> array.</p><p>2: <span class="code">input_count</span> is the <span class="code">unsigned long</span> count of elements in the <span class="code">input</span> array. When hashing in split segments, the value must be a multiple of 32, with the exception of the end segment.</p><p>3: <span class="code">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p>4: <span class="code">s</span> is a <span class="code">struct wsp_hash_32_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_32_finalize()</span> is the finalization function that accepts the following argument.</p><p>1: <span class="code">s</span> is a <span class="code">struct wsp_hash_32_s</span> pointer. <span class="code">s.mix</span> contains the finalized hash digest result.</p><p>The return value data type is <span class="code">void</span>.</p><h3>Example</h3><code>#include &lt;stdio.h&gt;
#include "wsp_hash_32.h"

int main(void) {
  struct wsp_hash_32_s s;
  uint8_t input[8] = {'m', 'e', 's', 's', 'a', 'g', 'e', 0};
  unsigned char i = 0;

  while (i != 10) {
    i++;
    printf("All-at-once result %u is 0x%08x.\n", i, wsp_hash_32(8, input));
    input[7]++;
  }

  input[7] = 0;
  i = 0;

  while (i != 10) {
    i++;
    wsp_hash_32_initialize(&s);
    wsp_hash_32_transform(0, 8, input, &s);
    wsp_hash_32_finalize(&s);
    input[7]++;
    printf("Segmented result %u is 0x%08x.\n", i, s.mix);
  }

  return 0;
}</code><h3>Requirements</h3><p class="no-margin-bottom">It adheres to the C99 standard draft (ISO/IEC 9899:1999), although it's convertible to other programming languages and standards.</p></div><div class="section"><h2>Explanation</h2><p>This 32-bit non-cryptographic hashing algorithm is designed to hash keys of all sizes as quickly as possible with minimal collisions across all truncated bit sizes.</p><p>It's the fastest portable 32-bit hashing algorithm with good statistical quality relevant to non-cryptographic hashing.<p>It's portable for both 32-bit and 64-bit systems.</p><p>It meets strict compliance, portability and code security requirements.</p><p>Multi-byte memory reading is designed primarily for systems with little-endian byte order, although big-endian memory reading is functional with similar quality and speed results.</p><p>In rare instances when hash table states must persist after program termination and re-used in multiple systems with varying endianness, keys should be re-hashed during initialization instead of slowing down runtime hashing with byte order alignment.</p><p>In rare instances when byte order is expected to change during runtime, using a <a href="/wsp-hash-oaat/">one-at-a-time hashing algorithm</a> is a better alternative.</p><p>It doesn't use modulus, multiplication or division arithmetic operations.</p><p>It supports unlimited input length by splitting <span class="code">input</span> bits into descending segments of 256, 128, 64 and the remaining 8–63 bits. All-at-once hashing is the faster option, but it isn't required and the digest results are consistent when hashing in partial segments.</p><p>Single-threaded, instruction-level parallelism with low-cost addition and bitwise instructions work well on a wide range of CPU queue loads and devices.</p><p>Without considering bit distribution calculations, it passes SMHasher collision tests using both big endian and little endian byte orders.</p><p>Seed tests in SMHasher are omitted to both discourage using hashing algorithms as PRNGs and prevent collision vulnerabilities from 2³² different initialized states.</p><p>There aren't any bit distribution calculation percentages exceeding 10% in the worst instances of the aforementioned tests, which suggests there aren't any critical distribution vulnerabilities relevant to non-cryptographic hashing.</p><p>Avalanche tests in SMHasher are omitted as strict avalanche criterion is only relevant to the analysis of cryptographic hash function output predictability.</p><p>Furthermore, the following code tests collision counts for truncated digests against each of the 8 bits flipped within a single input byte ranging from 1 to 255 at all positions for all <span class="code">input_count</span> values ranging from 1 to 256.</p><code>#include &lt;stdio.h&gt;
#include "wsp_hash_32.h"

int main(void) {
  uint8_t input[256];
  uint32_t result = 0;
  uint32_t result_flipped = 1;
  unsigned long bit_collisions_counts[32];
  unsigned short sparse_byte = 0;
  unsigned short i = 0;
  unsigned short j = 0;
  unsigned short k = 0;
  unsigned short l = 0;
  unsigned short m = 0;

  while (i != 32) {
    bit_collisions_counts[i] = 0;
    i++;
  }

  i = 1;

  while (sparse_byte != 16) {
    while (i != 256) {
      j = 1;

      while (j != 256) {
        k = 0;

        while (k != j) {
          while (l != j) {
            input[l] = sparse_byte;
            l++;
          }

          if (sparse_byte == i) {
            k = j;
            l = 0;
            continue;
          }

          input[k] = i;
          result = wsp_hash_32(j, input);
          l = 0;

          while (l != 8) {
            input[k] = input[k] ^ (1 << l);
            result_flipped = wsp_hash_32(j, input);
            input[k] = input[k] ^ (1 << l);
            m = 1;

            while (m != 32) {
              if (
                (result & ((2 << m) - 1)) == (result_flipped & ((2 << m) - 1))
              ) {
                bit_collisions_counts[m - 1]++;
              }

              m++;
            }

            l++;
            m = 0;
          }

          k++;
          l = 0;
        }

        j++;
        k = 0;
      }

      i++;
    }

    sparse_byte++;
    i = 1;
  }

  i = 2;
  j = 0;

  while (i != 33) {
    printf("%2u-Bit Segmented Collisions: %9lu\n",
           i,
           bit_collisions_counts[i - 2]);
    i++;
    j++;
  }

  return 0;
}</code><p>The following collision results demonstrate a sufficient collision-based avalanche effect in the worst instance with non-cryptographic, universal hashing relevance.</p><code>Avalanche Collision Results Among 1 Billion 1-Bit Sparse Keys at Varying Lengths

 2-Bit Segmented Collisions: 267930841
 3-Bit Segmented Collisions: 135013310
 4-Bit Segmented Collisions:  67964843
 5-Bit Segmented Collisions:  34162986
 6-Bit Segmented Collisions:  17250096
 7-Bit Segmented Collisions:   8699038
 8-Bit Segmented Collisions:   4354013
 9-Bit Segmented Collisions:   2208362
10-Bit Segmented Collisions:   1131627
11-Bit Segmented Collisions:    586244
12-Bit Segmented Collisions:    299872
13-Bit Segmented Collisions:    154559
14-Bit Segmented Collisions:     83441
15-Bit Segmented Collisions:     47000
16-Bit Segmented Collisions:     29634
17-Bit Segmented Collisions:     20410
18-Bit Segmented Collisions:      4062
19-Bit Segmented Collisions:      2080
20-Bit Segmented Collisions:      1015
21-Bit Segmented Collisions:       493
22-Bit Segmented Collisions:       237
23-Bit Segmented Collisions:       132
24-Bit Segmented Collisions:        60
25-Bit Segmented Collisions:        31
26-Bit Segmented Collisions:        19
27-Bit Segmented Collisions:         7
28-Bit Segmented Collisions:         4
29-Bit Segmented Collisions:         4
30-Bit Segmented Collisions:         2
31-Bit Segmented Collisions:         2
32-Bit Segmented Collisions:         2</code><p>The 2 32-bit collisions out of 125 million groups of 8 single-bit flip tests proves the worst instances are rare enough to be considered random occurrences in practical implementations.</p><p>The semi-linear collision increments after each truncation are within an acceptable range based on the probability of collisions at each bit size. For example, 200-300 million collisions in the lower 2 bits are expected out of 1 billion total keys, but only up to a few are expected in the full 32 bits.</p><p>Compared to CityHash32 v1.1, the speed's approximately 68% faster on average for small keys and 71% faster on average for large keys.</p><p>Compared to Lookup3, the speed's approximately 20% faster on average for small keys and 300% faster on average for large keys.</p><p>Furthermore, Lookup3 relies on direct pointer type conversions and unaligned memory reading.</p><p>Compared to 32-bit Murmur3, the speed's approximately 45% faster on average for small keys and 300% faster on average for large keys.</p><p>Compared to XXHash32, the speed's at least 46% faster on average for small keys and 30% faster for large keys.</p><p class="no-margin-bottom">All speed tests are performed locally on a Pixelbook Go M3 using Debian.</p></div><div class="no-margin-bottom section"><h2>Games</h2><div class="game no-margin-bottom no-margin-top"><a href="/contrivity/">Contrivity</a><h3>Contrivity</h3><p>Spawn into the hostile quantum laboratory and destroy oscillations.</p></div></div></main><footer><div class="no-margin-bottom"><p>&copy; 2024 William Stafford Parsons</p><ul><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li><li><a href="/#games">Games</a></li><li><a href="/#research">Research</a></li></ul><ul class="social-media"><li><a href="https://github.com/williamstaffordparsons" target="_blank"><img src="/icon-github.jpg"></a></li></ul><p style="color:#888;font-size:12px;line-height:19px;margin:52px 0 0;">All external mentions of William Stafford Parsons and associated intellectual property may contain either fraudulent claims or outdated content, especially when referencing subject matter not contained herein. All depictions of peril in games by William Stafford Parsons are for fictional gaming entertainment purposes only.</p></div></footer></div></body></html>
