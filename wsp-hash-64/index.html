<!DOCTYPE html><html lang="en"><head><title>WSP-Hash-64: The Fastest Portable 64-Bit Hashing Algorithm</title><link href="https://williamstaffordparsons.github.io/wsp-hash-64/" rel="canonical"><link href="/favicon.ico" rel="icon" type="image/x-icon"><meta content="initial-scale=1,width=device-width" name="viewport"><meta charset="utf-8"><style type="text/css">a{color:#000;font-weight:bold;letter-spacing:-0.2px;text-decoration:none;}body,html{background:#fff;color:#000;font-family:sans-serif;font-size:14px;font-weight:normal;line-height:25px;margin:0;overflow-x:hidden;width:100%;}code{background:#eee;border-radius:4px;box-sizing:border-box;color:#111;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;height:auto;letter-spacing:-0.2px;line-height:19px;margin:8px 0 17px;overflow-x:scroll;padding:28px 31px 25px;white-space:pre;width:100%}footer{display:inline-block;margin:100px 0;width:100%;}footer ul{display:inline-block;}footer ul{margin:55px 0 0;padding:0;width:100%;}footer ul li{display:inline-block;float:left;line-height:18px;margin:0 15px 5px 0;}footer ul li a{font-size:12px;float:left;}footer .social-media a{display:block;float:left;}footer .social-media a img{height:16px;}h1,h2,h3{display:inline-block;font-weight:normal;text-transform:uppercase;width:100%;}h1{font-size:23px;letter-spacing:-0.9px;line-height:32px;margin:-6px 0 34px;word-spacing:1.4px;}h2{font-size:19px;letter-spacing:-0.6px;line-height:42px;margin:0 0 24px;padding-top:18px;}h3{font-size:14px;letter-spacing:-0.3px;margin:10px 0 20px;}p{box-sizing:border-box;color:#555;display:inline-block;margin:0 0 17px;width:100%;}p .code{background:#eee;border-radius:4px;color:#111;display:inline-block;font-family:monospace;font-size:11px;font-weight:normal;letter-spacing:-0.2px;line-height:17px;margin:2px 1px;padding:4px 6px 0;}.game{background:#000;border-radius:4px;box-sizing:border-box;margin:0 0 30px;padding:21px 32px;position:relative;}.game.no-margin-top{margin-top:5px !important;}.game a{height:100%;left:0;position:absolute;text-indent:-9999px;top:0;width:100%;}.game h3{color:#fff;font-weight:bold;line-height:30px;margin:3px 0 0;}.game img{display:block;height:32px;margin-top:12px;width:32px;}.game p{color:#999;margin-bottom:5px;}.icon{float:left;line-height:32px;}.icon img{float:left;height:32px;margin-right:15px;}.no-margin-bottom{margin-bottom:0 !important;}.no-margin-left{margin-left:0 !important;}.no-margin-top{margin-top:0 !important;}.section{margin-bottom:40px;position:relative;}</style></head><body><div style="box-sizing:border-box;margin:0 auto;max-width:720px;padding:0 25px;width:100%;"><header style="display:inline-block;padding:105px 0 70px;width:100%;"><a class="icon" href="/"><img src="/icon.jpg">William Stafford Parsons</a></header><main style="min-height:280px;width:100%;"><h1>WSP-Hash-64: The Fastest Portable 64-Bit Hashing Algorithm With Aligned Multi-Byte Memory Reading and Good Quality</h1><div class="section"><p class="no-margin-bottom"><a href="https://github.com/williamstaffordparsons/wsp-hash-64">WSP-Hash-64</a> is a 64-bit hashing algorithm as a substantial improvement to CityHash64, FarmHash64, 64-bit MurmurHash3 x64 and x86, 64-bit SpookyHashV2 and XXHash64.</p></div><div class="section"><h2>Library</h2><h3 class="no-margin-top">Source</h3><p><a href="https://raw.githubusercontent.com/williamstaffordparsons/wsp-hash-64/refs/heads/master/wsp_hash_64.c">wsp_hash_64.c</a><br><a href="https://raw.githubusercontent.com/williamstaffordparsons/wsp-hash-64/refs/heads/master/wsp_hash_64.h">wsp_hash_64.h</a></p><h3>Reference</h3><p><span class="code">wsp_hash_64()</span> is the all-at-once hashing function that accepts the 2 following arguments in left-to-right order.</p><p>1: <span class="code">input_count</span> is the <span class="code">unsigned long</span> count of elements in the <span class="code">input</span> array.</p><p>2: <span class="code">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p>The return value data type is <span class="code">uint64_t</span>.</p><p>It returns the 64-bit unsigned integer hash digest result.</p><p><span class="code no-margin-left">wsp_hash_64_initialize()</span> is the initialization function that accepts the following argument.</p><p>1: <span class="code">s</span> is the <span class="code">struct wsp_hash_64_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_64_transform()</span> is the core hashing loop that accepts the 4 following arguments in left-to-right order.</p><p>1: <span class="code">i</span> is the <span class="code">unsigned long</span> starting index position of elements in the <span class="code">input</span> array.</p><p>2: <span class="code">input_count</span> is the <span class="code">unsigned long</span> count of elements in the <span class="code">input</span> array. When hashing in split segments, the value must be a multiple of 32, with the exception of the end segment.</p><p>3: <span class="code">input</span> is the <span class="code">const uint8_t</span> array to hash.</p><p>4: <span class="code">s</span> is the <span class="code">struct wsp_hash_64_s</span> pointer.</p><p><span class="code no-margin-left">wsp_hash_64_finalize()</span> is the finalization function that accepts the following argument.</p><p>1: <span class="code">s</span> is the <span class="code">struct wsp_hash_64_s</span> pointer. <span class="code">s.state</span> contains the finalized hash digest result.</p><p>The return value data type is <span class="code">void</span>.</p><h3>Example</h3><code>#include &lt;stdio.h&gt;
#include "wsp_hash_64.h"

int main(void) {
  struct wsp_hash_64_s s;
  uint8_t input[8] = {'m', 'e', 's', 's', 'a', 'g', 'e', 0};
  unsigned char i = 0;

  while (i != 10) {
    i++;
    printf("All-at-once result %u is 0x%016lx.\n", i, wsp_hash_64(8, input));
    input[7]++;
  }

  input[7] = 0;
  i = 0;

  while (i != 10) {
    i++;
    wsp_hash_64_initialize(&s);
    wsp_hash_64_transform(0, 8, input, &s);
    wsp_hash_64_finalize(&s);
    input[7]++;
    printf("Segmented result %u is 0x%016lx.\n", i, s.mix);
  }

  return 0;
}</code><h3>Requirements</h3><p class="no-margin-bottom">It adheres to the C99 standard draft (ISO/IEC 9899:1999), although it's convertible to other programming languages and standards.</p></div><div class="section"><h2>Explanation</h2><p>WSP-Hash-64 is designed to hash keys of all sizes as quickly as possible with minimal collisions across all truncated bit sizes.</p><p>It's the fastest portable 64-bit hashing algorithm with good statistical quality relevant to non-cryptographic hashing.</p><p>It's portable for 64-bit systems. There's an alternative <a href="/wsp-hash-32/">32-bit hashing algorithm</a> for 32-bit systems.</p><p>It meets strict compliance, portability and code security requirements.</p><p>Multi-byte memory reading is designed primarily for systems with little-endian byte order, although big-endian memory reading is functional with similar quality and speed results.</p><p>In rare instances when hash table states must be saved after program termination and re-used in multiple systems with varying endianness, keys should be re-hashed during initialization instead of slowing down runtime hashing with byte order alignment.</p><p>In rare instances when byte order is expected to change during runtime, using a <a href="/wsp-hash-oaat/">one-at-a-time hashing algorithm</a> is a better alternative.</p><p>It doesn't use modulus, multiplication or division arithmetic operations.</p><p>It supports unlimited input length by splitting <span class="code">input</span> bytes into descending segments of 256, 128, 64 and the remaining 8–63 bits. All-at-once hashing is the faster option, but it isn't required and the digest results are consistent when hashing in partial segments.</p><p>Single-threaded, instruction-level parallelism with low-cost addition and bitwise instructions work well on a wide range of CPU queue loads and devices.</p><p>Without considering bit distribution calculations, it passes SMHasher collision tests with both 64-bit output and low 32-bit output using both big endian and little endian byte orders.</p><p>Seed tests in SMHasher are omitted to both discourage using hashing algorithms as PRNGs and prevent collision vulnerabilities from 2³² different initialized states.</p><p>There aren't any bit distribution calculation percentages exceeding 5% in the worst instances of the aforementioned tests, which suggests there aren't any critical distribution vulnerabilities relevant to non-cryptographic hashing.</p><p>Avalanche tests in SMHasher are omitted as strict avalanche criterion is only relevant to the analysis of cryptographic hash function output predictability.</p><p>Furthermore, the following code tests collision counts for truncated digests against each of the 8 bits flipped within a single input byte ranging from 1 to 255 at all positions for all <span class="code">input_count</span> values ranging from 1 to 256.</p><code>#include &lt;stdio.h&gt;
#include "wsp_hash_64.h"

int main(void) {
  uint8_t input[256];
  uint64_t result = 0;
  uint64_t result_flipped = 1;
  unsigned long bit_collisions_counts[64];
  unsigned short sparse_byte = 0;
  unsigned short i = 0;
  unsigned short j = 0;
  unsigned short k = 0;
  unsigned short l = 0;
  unsigned short m = 0;

  while (i != 64) {
    bit_collisions_counts[i] = 0;
    i++;
  }

  i = 1;

  while (sparse_byte != 16) {
    while (i != 256) {
      j = 1;

      while (j != 256) {
        k = 0;

        while (k != j) {
          while (l != j) {
            input[l] = sparse_byte;
            l++;
          }

          if (sparse_byte == i) {
            k = j;
            l = 0;
            continue;
          }

          input[k] = i;
          result = wsp_hash_64(j, input);
          l = 0;

          while (l != 8) {
            input[k] = input[k] ^ (1 << l);
            result_flipped = wsp_hash_64(j, input);
            input[k] = input[k] ^ (1 << l);
            m = 1;

            while (m != 64) {
              if (
                (result & ((2UL << m) - 1UL)) == (result_flipped & ((2UL << m)
                  - 1UL))
              ) {
                bit_collisions_counts[m - 1]++;
              }

              m++;
            }

            l++;
            m = 0;
          }

          k++;
          l = 0;
        }

        j++;
        k = 0;
      }

      i++;
    }

    sparse_byte++;
    i = 1;
  }

  i = 2;
  j = 0;

  while (i != 65) {
    printf("%2u-Bit Segmented Collisions: %9lu\n",
           i,
           bit_collisions_counts[i - 2]);
    i++;
    j++;
  }

  return 0;
}</code><p>The following collision results demonstrate a sufficient collision-based avalanche effect in the worst instance with non-cryptographic, universal hashing relevance.</p><code>Avalanche Collision Results Among 1 Billion 1-Bit Sparse Keys at Varying Lengths

 2-Bit Segmented Collisions: 273414977
 3-Bit Segmented Collisions: 138972645
 4-Bit Segmented Collisions:  71405334
 5-Bit Segmented Collisions:  36949894
 6-Bit Segmented Collisions:  19201445
 7-Bit Segmented Collisions:  10078202
 8-Bit Segmented Collisions:   4920417
 9-Bit Segmented Collisions:   2552460
10-Bit Segmented Collisions:   1394152
11-Bit Segmented Collisions:    824942
12-Bit Segmented Collisions:    382725
13-Bit Segmented Collisions:    195935
14-Bit Segmented Collisions:    111663
15-Bit Segmented Collisions:     69770
16-Bit Segmented Collisions:     33368
17-Bit Segmented Collisions:     21773
18-Bit Segmented Collisions:     17170
19-Bit Segmented Collisions:     14915
20-Bit Segmented Collisions:      3837
21-Bit Segmented Collisions:      3295
22-Bit Segmented Collisions:      3001
23-Bit Segmented Collisions:      2882
24-Bit Segmented Collisions:        87
25-Bit Segmented Collisions:        38
26-Bit Segmented Collisions:        26
27-Bit Segmented Collisions:        10
28-Bit Segmented Collisions:         2
29-Bit Segmented Collisions:         2
30-Bit Segmented Collisions:         0
31-Bit Segmented Collisions:         0
32-Bit Segmented Collisions:         0
33-Bit Segmented Collisions:         0
34-Bit Segmented Collisions:         0
35-Bit Segmented Collisions:         0
36-Bit Segmented Collisions:         0
37-Bit Segmented Collisions:         0
38-Bit Segmented Collisions:         0
39-Bit Segmented Collisions:         0
40-Bit Segmented Collisions:         0
41-Bit Segmented Collisions:         0
42-Bit Segmented Collisions:         0
43-Bit Segmented Collisions:         0
44-Bit Segmented Collisions:         0
45-Bit Segmented Collisions:         0
46-Bit Segmented Collisions:         0
47-Bit Segmented Collisions:         0
48-Bit Segmented Collisions:         0
49-Bit Segmented Collisions:         0
50-Bit Segmented Collisions:         0
51-Bit Segmented Collisions:         0
52-Bit Segmented Collisions:         0
53-Bit Segmented Collisions:         0
54-Bit Segmented Collisions:         0
55-Bit Segmented Collisions:         0
56-Bit Segmented Collisions:         0
57-Bit Segmented Collisions:         0
58-Bit Segmented Collisions:         0
59-Bit Segmented Collisions:         0
60-Bit Segmented Collisions:         0
61-Bit Segmented Collisions:         0
62-Bit Segmented Collisions:         0
63-Bit Segmented Collisions:         0
64-Bit Segmented Collisions:         0</code><p>0 64-bit collisions out of 125 million groups of 8 single-bit flip tests proves the worst instances are rare enough to be considered random occurrences in practical implementations.</p><p>The semi-linear collision increments after each truncation are within an acceptable range based on the probability of collisions at each bit size. For example, 200-300 million collisions in the lower 2 bits are expected out of 1 billion total keys, but only up to a few are expected in the range of 32 to 64 bits.</p><p>It's compared to the fastest portable 64-bit hashing algorithms that aren't limited by specific programming languages, platform optimizations or portabillity macros. For example, it's 75% to 300% faster than RapidHash without platform-specific instructions. Furthermore, the expressions in the core mixing loop are structured conveniently for compatiblity with SIMD and other intrinsics.</p><p>Compared to CityHash64, the speed's approximately 21% faster on average for small keys and 19% faster on average for large keys.</p><p>Compared to FarmHash64, the speed's approximately 16% faster on average for small keys and 18% faster on average for large keys.</p><p>Compared to 64-bit MurmurHash3 x64 and x86, the speed's approximately 25% faster on average for small keys and 145% faster on average for large keys.</p><p>Compared to 64-bit SpookyHashV2, the speed's approximately 40% faster on average for small keys and 22% faster on average for large keys.</p><p>Compared to XXHash64, the speed's at least 26% faster on average for small keys and 21% faster for large keys.</p><p class="no-margin-bottom">All speed tests are performed locally on a Pixelbook Go M3 using Debian.</p></div><div class="no-margin-bottom section"><h2>Games</h2><div class="game no-margin-bottom no-margin-top"><a href="/contrivity/">Contrivity</a><h3>Contrivity</h3><p>Spawn into the hostile quantum laboratory and destroy oscillations.</p></div></div></main><footer><div class="no-margin-bottom"><p>&copy; 2024 William Stafford Parsons</p><ul><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li><li><a href="/#games">Games</a></li><li><a href="/#research">Research</a></li></ul><ul class="social-media"><li><a href="https://github.com/williamstaffordparsons"><img src="/icon-github.jpg"></a></li></ul><p style="color:#888;font-size:12px;line-height:19px;margin:52px 0 0;">All external mentions of William Stafford Parsons and associated intellectual property may contain either fraudulent claims or outdated content, especially when referencing subject matter not contained herein. All depictions of peril in games by William Stafford Parsons are for fictional gaming entertainment purposes only.</p></div></footer></div></body></html>
